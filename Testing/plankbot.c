#pragma config(Sensor, in1,    irSensor1,      sensorLineFollower)
#pragma config(Sensor, in2,    irSensor2,      sensorLineFollower)
#pragma config(Sensor, in3,    irSensor3,      sensorLineFollower)
#pragma config(Motor,  port2,           LeftMotor,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           RightMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           ArmMotor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           Extender,      tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//configuring integers to default values and use in code below
//int leftX,leftY and rightX,rightY are used for the joysticks on the controller
//setting to 0 at boot will make the resting position of the sticks set to 0
//or no input causing to motors to move
int leftX = 0;
int leftY = 0;
int rightY = 0;
int rightX = 0;

//constant boolean named on and set to true or in other words (yes it is on)
const bool on = true;

//int thresh is used to set the deadzone of the joysticks
//this value can be tweaked to the drivers request
//a lower value gives more control at low speeds but small movements are
//very pronounced and can lead to "jerky" driving
int thresh = 2;

//we are making a task drive to keep code organized
//think of this as a container that we place all code that has
//to do with driving in and we label it and place it on a shelf to be used later
task drive()
{
	while(on) //on is referencing the const bool "on"
	{
		//below is mapping the left joystick to move wheels in an arcade style drive
		//arcade is mostly prefered leaving the second joystick open for arm movement
		motor[LeftMotor] = -leftX - leftY;
		motor[RightMotor] = -leftX + leftY;
		//If button 8D is pressed it will activate the line follow funtion.
	}
}

//below is the container we put any code that has to
//do with the arm and or attachments that interact with game pieces
task manipulator()
{
	while(on)
	{
		//below we are setting the ArmMotor to a value based on the
		//position of the right joystick going up and down
		motor[ArmMotor] = rightY;

		if(vexRT[Btn6U])
		{
			motor[Extender] = 127;
		}
		else if(vexRT[Btn6D])
		{
			motor[Extender] = -127;
		}
		else
		{
			motor[Extender] = 0;
		}
	}
}

//This is the code for the line following program.
task autonomous()
{
	while(vexRT[Btn8D])
	{
		if(SensorValue[irSensor1] < 245)//when the IR sensor detects a value less than 245(white) it will run the left motor.
		{
			motor[LeftMotor] = -127;
		}
		if(SensorValue[irSensor2] < 245)//when the IR sensor detects a value less than 245(white) it will run the right motor.
		{
			motor[RightMotor] = 127;
		}
	}
}

//task main is, to keep following out analogy the place where we give
//instructions to actually go and grab the boxes that we labeled and use
//their contents
task main()
{
	//startTask is telling the program at boot to load drive and manipulator tasks
	//if you add more tasks be sure that they are added here so they will run at boot if
	//that is the desired action.
	startTask(drive);
	startTask(manipulator);
	startTask(autonomous);
	
	while(on) //"while true"
	{
		//here is where we actually apply the threshold
		//you may find that added a second threshold integer
		//and using it for arm control
		//this will give you more range for driving and opening up your low end control
		//while still leaving the manipulator slow and consistant... very good for precision grabbing
		rightX = vexRT(Ch1);
		if(abs(rightX)<thresh){
			rightX = 0;
		}
		rightY = vexRT(Ch2);
		if(abs(rightY)<thresh){
			rightY = 0;
		}
		leftY = vexRT(Ch3);
		if(abs(leftY)<thresh){
			leftY = 0;
		}
		leftX = vexRT(Ch4);
		if(abs(leftX)<thresh){
			leftX = 0;
		}
	}
}
