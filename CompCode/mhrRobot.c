#pragma config(Sensor, in1,    irSensorR,      sensorLineFollower)
#pragma config(Sensor, in2,    irSensorL,      sensorLineFollower)
#pragma config(Motor,  port2,           LeftMotor,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           RightMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           ArmMotor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           Extender,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           ManiServo,     tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//configuring integers to default values and use in code below
//int leftX,leftY and rightX,rightY are used for the joysticks on the controller
//setting to 0 at boot will make the resting position of the sticks set to 0
//or no input causing to motors to move
int leftX = 0;
int leftY = 0;
int rightY = 0;
int rightX = 0;

//constant boolean named on and set to true or in other words (yes it is on)
const bool on = true;

//int thresh is used to set the deadzone of the joysticks
//this value can be tweaked to the drivers request
//a lower value gives more control at low speeds but small movements are
//very pronounced and can lead to "jerky" driving
int thresh = 2;
int armThresh = 5;

//value recieved from the ir sensor
int irReturns = 305;

//we are making a task drive to keep code organized
//think of this as a container that we place all code that has
//to do with driving in and we label it and place it on a shelf to be used later
task drive()
{
	while(on) //on is referencing the const bool "on"
	{
		//below is mapping the left joystick to move wheels in an arcade style drive
		//arcade is mostly prefered leaving the second joystick open for arm movement
		motor[LeftMotor] = -leftX - leftY;
		motor[RightMotor] = -leftX + leftY;

		//If button 8D is pressed it will activate the line follow funtion.
		while(vexRT[Btn8U])//IR sensor code.(WORK IN PROGRESS)
		{
			//left sensor sees white
			if(SensorValue[irSensorL] < irReturns)
			{
				//turn left to avoid white
				motor[LeftMotor] = 0;
				motor[RightMotor] = 70;

			}

			//right sensor sees white
			if(SensorValue[irSensorR] < irReturns)
			{
				//turn right to avoid white
				motor[LeftMotor] = -70;
				motor[RightMotor] = 0;
			}

			//left and right sensor sees black
			if(SensorValue[irSensorL && irSensorR] > irReturns)
			{
				//drive forward
				motor[LeftMotor] = -65;
				motor[RightMotor] = 65;
			}
		}
	}
}

//below is the container we put any code that has to
//do with the arm and or attachments that interact with game pieces
task manipulator()
{
	while(on)
	{
		//below we are setting the ArmMotor to a value based on the
		//position of the right joystick going up and down
		motor[ArmMotor] = rightY / armThresh;

		if(vexRT[Btn6U])
		{
			motor[Extender] = 100;
		}
		else if(vexRT[Btn6D])
		{
			motor[Extender] = -100;
		}
		else
		{
			motor[Extender] = 0;
		}

		if(vexRT[Btn5U])
		{
			motor[ManiServo] = -127;
		}
		else if(vexRT[Btn5D])
		{
			motor[ManiServo] = 127;
		}
	}
}

//This is the code for the line following program.
task autonomous()
{

}

//task main is, to keep following out analogy the place where we give
//instructions to actually go and grab the boxes that we labeled and use
//their contents
task main()
{
	//startTask is telling the program at boot to load drive and manipulator tasks
	//if you add more tasks be sure that they are added here so they will run at boot if
	//that is the desired action.
	startTask(drive);
	startTask(manipulator);
	startTask(autonomous);

	while(on) //"while true"
	{
		//here is where we actually apply the threshold
		//you may find that added a second threshold integer
		//and using it for arm control
		//this will give you more range for driving and opening up your low end control
		//while still leaving the manipulator slow and consistant... very good for precision grabbing
		rightX = vexRT(Ch1);
		if(abs(rightX)<thresh){
			rightX = 0;
		}
		rightY = vexRT(Ch2);
		if(abs(rightY)<thresh){
			rightY = 0;
		}
		leftY = vexRT(Ch3);
		if(abs(leftY)<thresh){
			leftY = 0;
		}
		leftX = vexRT(Ch4);
		if(abs(leftX)<thresh){
			leftX = 0;
		}
	}
}
